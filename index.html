<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Winter Survival Factory</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #e0f7fa; /* Ice blue background */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent zooming on mobile */
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            display: flex;
            gap: 20px;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
            text-align: center;
            font-size: 14px;
            color: #333;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box">
            <span>ðŸ’µ</span> <span id="money-display">0</span>
        </div>
        <div class="stat-box">
            <span>ðŸ¥©</span> <span id="meat-display">0/10</span>
        </div>
    </div>

    <div id="instructions">
        Tap/Click to move â€¢ Gather Meat from Bears â€¢ Cook at Grill â€¢ Serve at Table
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * WINTER SURVIVAL FACTORY
 * A simple idle/management game logic implementation.
 */

// --- CONFIGURATION ---
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');

const UI_MONEY = document.getElementById('money-display');
const UI_MEAT = document.getElementById('meat-display');

// Game State
let money = 0;
let lastTime = 0;
const MAX_CARRY = 10; 
let unlockLevel = 1;

// Assets (Emojis as sprites)
const SPRITES = {
    player: 'ðŸ‘¨â€ðŸ³',
    bear: 'ðŸ»â€â„ï¸',
    meat_raw: 'ðŸ¥©',
    meat_cooked: 'ðŸ—',
    money: 'ðŸ’µ',
    grill: 'ðŸ”¥',
    table: 'ðŸ½ï¸',
    customer: 'ðŸ¥¶',
    snow: 'â„ï¸'
};

// Input
const input = { x: 0, y: 0, active: false };

// Entities
const player = {
    x: 0, y: 0, 
    targetX: 0, targetY: 0,
    speed: 200, // pixels per second
    stack: [] // Array of 'raw' or 'cooked'
};

const entities = {
    bears: [],
    machines: [],
    tables: [],
    customers: [],
    particles: [],
    triggers: [] // Unlock zones
};

// --- CORE FUNCTIONS ---

function resize() {
    CANVAS.width = window.innerWidth;
    CANVAS.height = window.innerHeight;
    
    // Reset player position if out of bounds (or on init)
    if (player.x === 0) {
        player.x = CANVAS.width / 2;
        player.y = CANVAS.height / 2;
        player.targetX = player.x;
        player.targetY = player.y;
    }
}

function init() {
    resize();
    window.addEventListener('resize', resize);
    
    // Mouse/Touch Input
    const setTarget = (e) => {
        const rect = CANVAS.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        player.targetX = clientX - rect.left;
        player.targetY = clientY - rect.top;
        input.active = true;
    };

    CANVAS.addEventListener('mousedown', setTarget);
    CANVAS.addEventListener('touchstart', setTarget, {passive: false});
    // Continuously update target if dragging
    CANVAS.addEventListener('mousemove', (e) => { if(e.buttons === 1) setTarget(e); });
    CANVAS.addEventListener('touchmove', (e) => { e.preventDefault(); setTarget(e); }, {passive: false});

    // Setup Level 1
    setupLevel();

    requestAnimationFrame(gameLoop);
}

function setupLevel() {
    // Add Grill
    entities.machines.push({
        x: CANVAS.width / 2 - 100,
        y: CANVAS.height / 2 + 50,
        w: 60, h: 60,
        timer: 0,
        cookingTime: 2000, // ms
        input: 0,
        output: 0,
        maxOutput: 3
    });

    // Add Table
    entities.tables.push({
        x: CANVAS.width / 2 + 100,
        y: CANVAS.height / 2 + 50,
        w: 60, h: 60,
        food: 0,
        maxFood: 5
    });

    // Add Trigger (Unlock Zone)
    entities.triggers.push({
        x: CANVAS.width / 2,
        y: CANVAS.height - 80,
        w: 120, h: 60,
        cost: 100,
        unlocked: false,
        label: "Unlock Speed"
    });
}

// --- GAME LOGIC ---

function spawnBear() {
    if (entities.bears.length < 5 + (unlockLevel * 2)) {
        entities.bears.push({
            x: Math.random() * (CANVAS.width - 60) + 30,
            y: Math.random() * (CANVAS.height / 2 - 100) + 50, // Top half of screen
            radius: 20,
            alive: true
        });
    }
}

function spawnCustomer() {
    if (entities.customers.length < 3) {
        // Spawn at bottom edge
        entities.customers.push({
            x: Math.random() * CANVAS.width,
            y: CANVAS.height + 50,
            target: null,
            state: 'walking_in', // walking_in, eating, leaving
            timer: 0,
            hasPaid: false
        });
    }
}

function update(dt) {
    // 1. Player Movement
    const dx = player.targetX - player.x;
    const dy = player.targetY - player.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if (dist > 5) {
        player.x += (dx / dist) * player.speed * dt;
        player.y += (dy / dist) * player.speed * dt;
    }

    // 2. Bear Interaction (Gathering)
    entities.bears.forEach(bear => {
        if (!bear.alive) return;
        const d = Math.hypot(player.x - bear.x, player.y - bear.y);
        if (d < 40 && player.stack.length < MAX_CARRY) {
            bear.alive = false;
            // Add 'raw' meat to stack
            player.stack.push('raw');
            spawnParticle(bear.x, bear.y, SPRITES.meat_raw);
        }
    });
    // Cleanup bears and spawn new ones
    entities.bears = entities.bears.filter(b => b.alive);
    if (Math.random() < 0.02) spawnBear();

    // 3. Machine Interaction (Cooking)
    entities.machines.forEach(machine => {
        // Check collision
        if (checkRectCollision(player, machine)) {
            // Drop off Raw Meat
            if (player.stack.length > 0 && player.stack[player.stack.length-1] === 'raw') {
                player.stack.pop();
                machine.input++;
            }
            // Pick up Cooked Meat
            if (machine.output > 0 && player.stack.length < MAX_CARRY) {
                machine.output--;
                player.stack.push('cooked');
                spawnParticle(machine.x, machine.y, SPRITES.meat_cooked);
            }
        }

        // Processing Logic
        if (machine.input > 0 && machine.output < machine.maxOutput) {
            machine.timer += dt * 1000;
            if (machine.timer > machine.cookingTime) {
                machine.input--;
                machine.output++;
                machine.timer = 0;
            }
        }
    });

    // 4. Table Interaction (Serving)
    entities.tables.forEach(table => {
        if (checkRectCollision(player, table)) {
            // Drop off Cooked Meat
            if (table.food < table.maxFood && player.stack.length > 0 && player.stack[player.stack.length-1] === 'cooked') {
                player.stack.pop();
                table.food++;
            }
        }
    });

    // 5. Customer Logic
    entities.customers.forEach(cust => {
        const table = entities.tables[0]; // Simple AI: go to first table

        if (cust.state === 'walking_in') {
            moveTo(cust, table.x, table.y + 40, 100, dt);
            if (Math.hypot(cust.x - table.x, cust.y - (table.y+40)) < 5) {
                if (table.food > 0) {
                    table.food--;
                    cust.state = 'eating';
                    cust.timer = 2000; // Eat for 2 seconds
                } else {
                    // Wait or leave if too long (simple: just wait)
                }
            }
        } else if (cust.state === 'eating') {
            cust.timer -= dt * 1000;
            if (cust.timer <= 0) {
                cust.state = 'leaving';
                // Pay Money
                money += 15;
                spawnParticle(cust.x, cust.y, SPRITES.money);
            }
        } else if (cust.state === 'leaving') {
            moveTo(cust, CANVAS.width / 2, CANVAS.height + 100, 100, dt);
            if (cust.y > CANVAS.height + 50) cust.hasPaid = true; // Mark for deletion
        }
    });
    // Cleanup customers
    entities.customers = entities.customers.filter(c => !c.hasPaid);
    if (Math.random() < 0.01) spawnCustomer();

    // 6. Triggers (Upgrades)
    entities.triggers.forEach(trig => {
        if (!trig.unlocked && checkRectCollision(player, trig)) {
            if (money >= trig.cost) {
                money -= trig.cost;
                trig.unlocked = true;
                unlockLevel++;
                player.speed += 50; // Speed upgrade
                trig.label = "Unlocked!";
            }
        }
    });

    // 7. Particles
    entities.particles.forEach(p => {
        p.y -= 50 * dt;
        p.life -= dt;
    });
    entities.particles = entities.particles.filter(p => p.life > 0);

    // Update UI
    UI_MONEY.innerText = money;
    UI_MEAT.innerText = `${player.stack.length}/${MAX_CARRY}`;
}

// --- RENDER ---

function draw() {
    // Clear
    CTX.fillStyle = '#e0f7fa';
    CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

    // Decor: Snow
    CTX.font = "20px Arial";
    CTX.fillStyle = "#fff";
    // (Static snow for performance in this simple example)
    CTX.globalAlpha = 0.5;
    CTX.fillText(SPRITES.snow, 100, 100);
    CTX.fillText(SPRITES.snow, CANVAS.width-100, 200);
    CTX.fillText(SPRITES.snow, CANVAS.width/2, CANVAS.height/2);
    CTX.globalAlpha = 1.0;

    // Triggers
    entities.triggers.forEach(t => {
        if (t.unlocked) return;
        CTX.fillStyle = 'rgba(0,0,0,0.2)';
        CTX.fillRect(t.x - t.w/2, t.y - t.h/2, t.w, t.h);
        CTX.fillStyle = '#333';
        CTX.font = "16px Arial";
        CTX.textAlign = "center";
        CTX.fillText(`ðŸ”’ ${t.cost}`, t.x, t.y + 5);
        CTX.font = "12px Arial";
        CTX.fillText(t.label, t.x, t.y + 20);
    });

    // Machines (Grills)
    entities.machines.forEach(m => {
        // Base
        CTX.fillStyle = '#555';
        CTX.fillRect(m.x - m.w/2, m.y - m.h/2, m.w, m.h);
        
        // Progress Bar
        if (m.input > 0) {
            CTX.fillStyle = '#eee';
            CTX.fillRect(m.x - m.w/2, m.y - m.h/2 - 10, m.w, 5);
            CTX.fillStyle = 'orange';
            CTX.fillRect(m.x - m.w/2, m.y - m.h/2 - 10, m.w * (m.timer / m.cookingTime), 5);
        }

        // Emoji
        CTX.font = "30px Arial";
        CTX.textAlign = "center";
        CTX.textBaseline = "middle";
        CTX.fillText(SPRITES.grill, m.x, m.y);

        // Output Stack Visual
        for(let i=0; i<m.output; i++) {
            CTX.font = "20px Arial";
            CTX.fillText(SPRITES.meat_cooked, m.x, m.y - 30 - (i*10));
        }
    });

    // Tables
    entities.tables.forEach(t => {
        CTX.fillStyle = '#8B4513';
        CTX.fillRect(t.x - t.w/2, t.y - t.h/2, t.w, t.h);
        CTX.textAlign = "center";
        CTX.font = "30px Arial";
        CTX.fillText(SPRITES.table, t.x, t.y + 5);

        // Food on table
        for(let i=0; i<t.food; i++) {
            CTX.font = "15px Arial";
            // Scatter slightly
            CTX.fillText(SPRITES.meat_cooked, t.x + (i*5) - 10, t.y - 10);
        }
    });

    // Bears
    entities.bears.forEach(b => {
        CTX.font = "30px Arial";
        CTX.textAlign = "center";
        CTX.textBaseline = "middle";
        CTX.fillText(SPRITES.bear, b.x, b.y);
        // Shadow
        CTX.fillStyle = "rgba(0,0,0,0.1)";
        CTX.beginPath();
        CTX.ellipse(b.x, b.y + 15, 15, 5, 0, 0, Math.PI*2);
        CTX.fill();
    });

    // Customers
    entities.customers.forEach(c => {
        CTX.font = "30px Arial";
        CTX.textAlign = "center";
        CTX.textBaseline = "middle";
        CTX.fillText(SPRITES.customer, c.x, c.y);
        if (c.state === 'eating') {
            CTX.font = "20px Arial";
            CTX.fillText("ðŸ˜‹", c.x + 15, c.y - 15);
        }
    });

    // Player
    CTX.font = "40px Arial";
    CTX.textAlign = "center";
    CTX.textBaseline = "middle";
    CTX.fillText(SPRITES.player, player.x, player.y);
    
    // Player Stack (The Tower!)
    player.stack.forEach((item, index) => {
        const sprite = item === 'raw' ? SPRITES.meat_raw : SPRITES.meat_cooked;
        CTX.font = "20px Arial";
        // Stack flows upward
        CTX.fillText(sprite, player.x, player.y - 30 - (index * 12));
    });

    // Particles
    entities.particles.forEach(p => {
        CTX.font = "20px Arial";
        CTX.fillText(p.char, p.x, p.y);
    });
}

// --- UTILITIES ---

function gameLoop(timestamp) {
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    update(dt);
    draw();

    requestAnimationFrame(gameLoop);
}

function checkRectCollision(circle, rect) {
    // Simple AABB approximation for gameplay feel
    return (circle.x > rect.x - rect.w/2 - 20 &&
            circle.x < rect.x + rect.w/2 + 20 &&
            circle.y > rect.y - rect.h/2 - 20 &&
            circle.y < rect.y + rect.h/2 + 20);
}

function moveTo(entity, tx, ty, speed, dt) {
    const dx = tx - entity.x;
    const dy = ty - entity.y;
    const dist = Math.hypot(dx, dy);
    if (dist > 1) {
        entity.x += (dx / dist) * speed * dt;
        entity.y += (dy / dist) * speed * dt;
    }
}

function spawnParticle(x, y, char) {
    entities.particles.push({x, y, char, life: 1.0});
}

// Start
init();

</script>
</body>
</html>