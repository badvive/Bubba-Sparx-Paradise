<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Winter Factory 2.0</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a; /* Dark border outside game */
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #dff6f5; /* Snow color */
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .stat-pill {
            background: rgba(255, 255, 255, 0.9);
            color: #2c3e50;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 18px;
            font-weight: 800;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
            border: 2px solid #ecf0f1;
            width: fit-content;
        }
        .icon { font-size: 20px; }
        #money-pill { color: #27ae60; }
        #meat-pill { color: #c0392b; }
        
        #tutorial {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            color: #546e7a;
            font-weight: bold;
            text-shadow: 0 1px 0 rgba(255,255,255,0.8);
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="stat-pill" id="money-pill">
            <span class="icon">ðŸ’µ</span> <span id="money-display">0</span>
        </div>
        <div class="stat-pill" id="meat-pill">
            <span class="icon">ðŸ¥©</span> <span id="meat-display">0 / 10</span>
        </div>
    </div>

    <div id="tutorial">
        DRAG TO MOVE â€¢ HARVEST BEARS â€¢ FILL THE BELT
    </div>
</div>

<script>
/**
 * WINTER FACTORY 2.0 - PROCEDURAL ART ENGINE
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiMoney = document.getElementById('money-display');
const uiMeat = document.getElementById('meat-display');

// --- GAME STATE ---
const state = {
    money: 0,
    camera: { x: 0, y: 0 },
    time: 0,
    snow: []
};

// --- CONFIG ---
const COLORS = {
    snow: '#dff6f5',
    snowShadow: '#bfe7e9',
    bear: '#fdfdfd',
    bearShadow: '#dbeff0',
    playerCoat: '#3498db',
    playerSkin: '#ffccaa',
    meatRaw: '#e74c3c',
    meatFat: '#ffcccc',
    meatCooked: '#8d6e63',
    belt: '#546e7a',
    beltMoving: '#37474f',
    metal: '#95a5a6',
    fire: '#e67e22',
    wood: '#a1887f'
};

const PLAYER_SPEED = 240;
const MAX_STACK = 10;

// --- ENTITIES ---
let player = {
    x: 0, y: 0,
    targetX: 0, targetY: 0,
    moving: false,
    stack: [], // 'raw', 'cooked'
    wobble: 0
};

let entities = []; // Bears, Machines, Tables, Customers
let particles = [];

// --- ART ASSETS (Procedural Drawing Functions) ---

function drawShadow(x, y, r) {
    ctx.fillStyle = 'rgba(0,50,60,0.15)';
    ctx.beginPath();
    ctx.ellipse(x, y, r, r/2, 0, 0, Math.PI*2);
    ctx.fill();
}

function drawBlock(x, y, w, h, z, color, topColor) {
    // Front face
    ctx.fillStyle = color;
    ctx.fillRect(x - w/2, y - h - z, w, h);
    // Top face (pseudo perspective)
    ctx.fillStyle = topColor || color;
    ctx.beginPath();
    ctx.moveTo(x - w/2, y - h - z);
    ctx.lineTo(x + w/2, y - h - z);
    ctx.lineTo(x + w/2 + 5, y - h - z - 10);
    ctx.lineTo(x - w/2 + 5, y - h - z - 10);
    ctx.fill();
    // Side face
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath();
    ctx.moveTo(x + w/2, y - h - z);
    ctx.lineTo(x + w/2 + 5, y - h - z - 10);
    ctx.lineTo(x + w/2 + 5, y - z - 10);
    ctx.lineTo(x + w/2, y - z);
    ctx.fill();
}

function drawMeatItem(x, y, type, index) {
    const isRaw = type === 'raw';
    const c = isRaw ? COLORS.meatRaw : COLORS.meatCooked;
    const yOff = y - (index * 14); // Stack height
    
    // Sway calculation
    const sway = Math.sin(state.time * 5 + index) * (player.moving ? 3 : 1);
    const xOff = x + sway;

    // Meat Body
    ctx.fillStyle = c;
    ctx.beginPath();
    ctx.roundRect(xOff - 12, yOff - 40, 24, 12, 4);
    ctx.fill();
    
    // Depth side
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(xOff - 12, yOff - 34, 24, 4);

    // Detail (Bone/Fat)
    if (isRaw) {
        ctx.fillStyle = COLORS.meatFat;
        ctx.beginPath();
        ctx.arc(xOff, yOff - 34, 3, 0, Math.PI*2);
        ctx.fill();
    } else {
        ctx.fillStyle = '#5d4037'; // Grill marks
        ctx.fillRect(xOff - 8, yOff - 38, 2, 8);
        ctx.fillRect(xOff + 0, yOff - 38, 2, 8);
        ctx.fillRect(xOff + 8, yOff - 38, 2, 8);
    }
}

function drawPlayerEntity(p) {
    drawShadow(p.x, p.y, 18);
    
    // Bounce animation
    const bounce = p.moving ? Math.abs(Math.sin(state.time * 10)) * 5 : 0;
    
    // Body (Coat)
    ctx.fillStyle = COLORS.playerCoat;
    ctx.beginPath();
    ctx.roundRect(p.x - 12, p.y - 35 - bounce, 24, 30, 8);
    ctx.fill();
    
    // Scarf
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(p.x - 14, p.y - 32 - bounce, 28, 8);
    
    // Head
    ctx.fillStyle = COLORS.playerSkin;
    ctx.beginPath();
    ctx.arc(p.x, p.y - 42 - bounce, 12, 0, Math.PI*2);
    ctx.fill();
    
    // Hat
    ctx.fillStyle = '#2c3e50';
    ctx.beginPath();
    ctx.arc(p.x, p.y - 46 - bounce, 13, Math.PI, 0);
    ctx.fill();

    // Stack rendering
    p.stack.forEach((type, i) => {
        drawMeatItem(p.x, p.y - 50 - bounce, type, i);
    });
}

function drawBearEntity(b) {
    // Breathing scale
    const breath = 1 + Math.sin(state.time * 2 + b.id) * 0.02;
    
    drawShadow(b.x, b.y, 30);
    
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.scale(breath, breath);
    
    // Body
    ctx.fillStyle = COLORS.bear;
    ctx.beginPath();
    ctx.ellipse(0, -15, 30, 25, 0, 0, Math.PI*2);
    ctx.fill();
    
    // Shading (Fur texture implication)
    ctx.fillStyle = COLORS.bearShadow;
    ctx.beginPath();
    ctx.ellipse(0, -5, 20, 10, 0, 0, Math.PI*2);
    ctx.fill();

    // Head
    ctx.fillStyle = COLORS.bear;
    ctx.beginPath();
    ctx.arc(-20, -25, 12, 0, Math.PI*2);
    ctx.fill();

    // Ears
    ctx.beginPath();
    ctx.arc(-28, -32, 4, 0, Math.PI*2);
    ctx.arc(-12, -32, 4, 0, Math.PI*2);
    ctx.fill();

    // Nose
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(-24, -25, 2, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
}

function drawMachineEntity(m) {
    // Base platform
    drawBlock(m.x, m.y, 70, 10, 0, '#7f8c8d', '#95a5a6');
    
    // Conveyor Belt
    ctx.save();
    ctx.translate(m.x, m.y - 15);
    ctx.rotate(-0.1); // Isometric tilt
    ctx.fillStyle = COLORS.belt;
    ctx.fillRect(-35, -5, 70, 20);
    
    // Animated belt stripes
    if (m.processing) {
        const offset = (state.time * 50) % 20;
        ctx.fillStyle = COLORS.beltMoving;
        for(let i = -35 + offset; i < 35; i += 20) {
             if (i < 30) ctx.fillRect(i, -5, 5, 20);
        }
    }
    ctx.restore();

    // Grill Unit
    drawBlock(m.x + 20, m.y - 10, 30, 30, 0, '#34495e', '#2c3e50');
    
    // Fire/Heat indicator
    if (m.processing) {
        ctx.fillStyle = `rgba(230, 126, 34, ${0.6 + Math.sin(state.time * 20)*0.2})`;
        ctx.beginPath();
        ctx.arc(m.x + 20, m.y - 40, 10, 0, Math.PI*2);
        ctx.fill();
    }

    // Output visual
    for(let i=0; i<m.output; i++) {
        drawMeatItem(m.x - 20, m.y - 10, 'cooked', i);
    }
}

function drawTableEntity(t) {
    drawBlock(t.x, t.y, 60, 20, 0, COLORS.wood, '#8d6e63');
    // Table Cloth
    ctx.fillStyle = 'white';
    ctx.fillRect(t.x - 30, t.y - 20, 60, 5);
    
    // Food
    for(let i=0; i<t.food; i++) {
        drawMeatItem(t.x - 20 + (i*10), t.y, 'cooked', 0);
    }
}

function drawCustomerEntity(c) {
    drawShadow(c.x, c.y, 15);
    // Simple Customer shape
    ctx.fillStyle = c.color;
    ctx.beginPath();
    ctx.moveTo(c.x, c.y);
    ctx.lineTo(c.x - 10, c.y - 40);
    ctx.lineTo(c.x + 10, c.y - 40);
    ctx.fill();
    
    ctx.fillStyle = '#ecf0f1'; // Hood
    ctx.beginPath();
    ctx.arc(c.x, c.y - 45, 10, 0, Math.PI*2);
    ctx.fill();
    
    // Action icon
    if (c.state === 'eating') {
        ctx.font = '20px Arial';
        ctx.fillText('ðŸ˜‹', c.x + 10, c.y - 50);
    }
}

function drawParticle(p) {
    ctx.globalAlpha = p.life;
    if (p.type === 'snow') {
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
    } else if (p.type === 'text') {
        ctx.fillStyle = '#27ae60';
        ctx.font = "bold 24px Arial";
        ctx.fillText(p.text, p.x, p.y);
    } else if (p.type === 'smoke') {
        ctx.fillStyle = '#bdc3c7';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
    }
    ctx.globalAlpha = 1.0;
}

// --- LOGIC HELPER ---
function getDist(o1, o2) {
    return Math.hypot(o1.x - o2.x, o1.y - o2.y);
}

// --- INITIALIZATION ---
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    // Set initial player pos
    if (player.x === 0) {
        player.x = canvas.width/2;
        player.y = canvas.height/2;
        player.targetX = player.x;
        player.targetY = player.y;
    }
}

function initGame() {
    resize();
    window.addEventListener('resize', resize);
    
    // Inputs
    const setTarget = (e) => {
        const t = e.touches ? e.touches[0] : e;
        player.targetX = t.clientX;
        player.targetY = t.clientY;
    };
    canvas.addEventListener('mousedown', (e) => {
        setTarget(e);
        canvas.addEventListener('mousemove', setTarget);
    });
    window.addEventListener('mouseup', () => canvas.removeEventListener('mousemove', setTarget));
    
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        setTarget(e);
        canvas.addEventListener('touchmove', setTarget);
    }, {passive:false});
    window.addEventListener('touchend', () => canvas.removeEventListener('touchmove', setTarget));

    // Create World
    // Machine
    entities.push({
        type: 'machine',
        x: canvas.width/2 - 80,
        y: canvas.height/2 + 50,
        input: 0, output: 0, maxOutput: 3,
        timer: 0, processing: false
    });
    
    // Table
    entities.push({
        type: 'table',
        x: canvas.width/2 + 80,
        y: canvas.height/2 + 50,
        food: 0, maxFood: 4
    });

    // Initial Bears
    for(let i=0; i<5; i++) spawnBear();
    
    // Snow Loop
    setInterval(() => {
        particles.push({
            type: 'snow',
            x: Math.random() * canvas.width,
            y: -10,
            speedY: Math.random() * 2 + 1,
            speedX: Math.random() * 1 - 0.5,
            size: Math.random() * 3 + 1,
            life: 1
        });
    }, 100);

    requestAnimationFrame(loop);
}

function spawnBear() {
    entities.push({
        type: 'bear',
        id: Math.random(),
        x: Math.random() * (canvas.width - 100) + 50,
        y: Math.random() * (canvas.height/2 - 100) + 100,
        hp: 1
    });
}

function spawnCustomer() {
    const table = entities.find(e => e.type === 'table');
    entities.push({
        type: 'customer',
        x: Math.random() * canvas.width,
        y: canvas.height + 50,
        target: table,
        state: 'walking',
        timer: 0,
        color: `hsl(${Math.random()*360}, 60%, 40%)`
    });
}

// --- MAIN LOOP ---
let lastTime = 0;

function loop(timestamp) {
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    state.time = timestamp / 1000;

    update(dt);
    draw();
    requestAnimationFrame(loop);
}

function update(dt) {
    // Player Move
    const dx = player.targetX - player.x;
    const dy = player.targetY - player.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    player.moving = dist > 5;
    
    if (dist > 5) {
        player.x += (dx/dist) * PLAYER_SPEED * dt;
        player.y += (dy/dist) * PLAYER_SPEED * dt;
    }

    // Entity Logic
    entities.forEach(e => {
        // Bear Interaction
        if (e.type === 'bear') {
            if (getDist(player, e) < 50 && player.stack.length < MAX_STACK) {
                // Harvest
                e.hp = 0; // Mark dead
                player.stack.push('raw');
                // Pop effect
                for(let i=0; i<5; i++) {
                    particles.push({
                        type: 'snow', x: e.x, y: e.y, 
                        speedX: (Math.random()-0.5)*100, speedY: (Math.random()-0.5)*100,
                        size: 4, life: 1
                    });
                }
            }
        }
        
        // Machine Interaction
        if (e.type === 'machine') {
            // Drop off
            if (getDist(player, e) < 70 && player.stack.length > 0 && player.stack[player.stack.length-1] === 'raw') {
                player.stack.pop();
                e.input++;
                e.processing = true;
            }
            // Pickup
            if (getDist(player, e) < 70 && e.output > 0 && player.stack.length < MAX_STACK) {
                e.output--;
                player.stack.push('cooked');
            }
            // Cook Process
            if (e.input > 0 && e.output < e.maxOutput) {
                e.timer += dt;
                if (Math.random() > 0.9) {
                    particles.push({
                        type:'smoke', x: e.x + 20, y: e.y - 30, 
                        speedY: -20, speedX: 0, size: 5, life: 1
                    });
                }
                if (e.timer > 1.5) { // Cook time
                    e.input--;
                    e.output++;
                    e.timer = 0;
                }
            } else {
                e.processing = false;
            }
        }
        
        // Table Interaction
        if (e.type === 'table') {
             if (getDist(player, e) < 70 && player.stack.length > 0 && player.stack[player.stack.length-1] === 'cooked' && e.food < e.maxFood) {
                player.stack.pop();
                e.food++;
             }
        }

        // Customer Logic
        if (e.type === 'customer') {
            if (e.state === 'walking') {
                const tx = e.target.x;
                const ty = e.target.y + 40;
                const d = Math.hypot(tx - e.x, ty - e.y);
                if (d > 5) {
                    e.x += (tx - e.x)/d * 100 * dt;
                    e.y += (ty - e.y)/d * 100 * dt;
                } else {
                    if (e.target.food > 0) {
                        e.target.food--;
                        e.state = 'eating';
                        e.timer = 2;
                    }
                }
            } else if (e.state === 'eating') {
                e.timer -= dt;
                if (e.timer <= 0) {
                    state.money += 15;
                    particles.push({type:'text', text:'+$15', x: e.x, y: e.y - 60, life:1, speedY: -50});
                    e.state = 'leaving';
                }
            } else if (e.state === 'leaving') {
                e.y += 100 * dt;
                if (e.y > canvas.height + 50) e.dead = true;
            }
        }
    });

    // Spawners
    if (entities.filter(e => e.type === 'bear').length < 5 && Math.random() < 0.02) spawnBear();
    if (entities.filter(e => e.type === 'customer').length < 3 && Math.random() < 0.01) spawnCustomer();

    // Cleanup
    entities = entities.filter(e => !e.dead && (e.type !== 'bear' || e.hp > 0));

    // Particles
    particles.forEach(p => {
        p.x += (p.speedX || 0) * dt;
        p.y += (p.speedY || 0) * dt;
        p.life -= dt;
    });
    particles = particles.filter(p => p.life > 0);
    
    // UI
    uiMoney.innerText = state.money;
    uiMeat.innerText = `${player.stack.length} / ${MAX_STACK}`;
}

function draw() {
    // Clear
    ctx.fillStyle = COLORS.snow;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Grid lines (for depth perception)
    ctx.strokeStyle = '#eef';
    ctx.beginPath();
    for(let i=0; i<canvas.width; i+=100) { ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); }
    for(let i=0; i<canvas.height; i+=100) { ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); }
    ctx.stroke();

    // Sort all renderable objects by Y position (Z-index)
    const renderList = [
        { type: 'player', y: player.y, draw: () => drawPlayerEntity(player) },
        ...entities.map(e => ({
            type: e.type,
            y: e.y,
            draw: () => {
                if (e.type === 'bear') drawBearEntity(e);
                if (e.type === 'machine') drawMachineEntity(e);
                if (e.type === 'table') drawTableEntity(e);
                if (e.type === 'customer') drawCustomerEntity(e);
            }
        }))
    ];

    renderList.sort((a, b) => a.y - b.y);

    // Draw Shadows first (globally to avoid weird overlaps, optional, but keeping inside draw functions for now for simplicity)
    
    // Draw Objects
    renderList.forEach(obj => obj.draw());

    // Draw Particles (always on top)
    particles.forEach(drawParticle);
}

// Start
initGame();

</script>
</body>
</html>
