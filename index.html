<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Winter Factory Tycoon</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; background: #dff6f5; overflow: hidden; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 20px; left: 20px; pointer-events: none; display: flex; flex-direction: column; gap: 10px; }
        .stat-pill { background: rgba(255, 255, 255, 0.95); color: #2c3e50; padding: 10px 20px; border-radius: 30px; font-size: 20px; font-weight: 800; display: flex; align-items: center; gap: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); border: 2px solid #ecf0f1; width: fit-content; transition: transform 0.1s; }
        #money-pill { color: #27ae60; border-color: #2ecc71; }
        #meat-pill { color: #c0392b; border-color: #e74c3c; }
        #reset-btn { pointer-events: auto; background: #e74c3c; color: white; border: none; padding: 5px 10px; border-radius: 5px; font-size: 12px; cursor: pointer; margin-top: 10px; font-weight: bold; opacity: 0.7; }
        #reset-btn:hover { opacity: 1; }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div class="stat-pill" id="money-pill"><span class="icon">ðŸ’µ</span> <span id="money-display">0</span></div>
        <div class="stat-pill" id="meat-pill"><span class="icon">ðŸ¥©</span> <span id="meat-display">0 / 10</span></div>
        <button id="reset-btn" onclick="resetGame()">RESET PROGRESS</button>
    </div>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiMoney = document.getElementById('money-display');
const uiMeat = document.getElementById('meat-display');

// --- COLORS & CONFIG ---
const COLORS = {
    snow: '#dff6f5', bear: '#fdfdfd', bearShadow: '#dbeff0',
    playerCoat: '#3498db', playerSkin: '#ffccaa',
    hunterCoat: '#c0392b', waiterCoat: '#27ae60', // Employee colors
    customerCoat: '#e67e22', customerHat: '#d35400',
    meatRaw: '#e74c3c', meatCooked: '#8d6e63',
    belt: '#546e7a', beltMoving: '#37474f',
    unlockLocked: '#95a5a6', unlockActive: '#2ecc71'
};

const BASE_SPEED = 240;
const MAX_STACK = 10;

// --- GAME STATE (With Save) ---
let state = {
    money: 0,
    time: 0,
    upgrades: {
        speed: 0,
        hunters: 0,
        waiters: 0
    }
};

// Load Save
const saveString = localStorage.getItem('winterFactorySave');
if (saveString) {
    try {
        const saved = JSON.parse(saveString);
        state.money = saved.money || 0;
        state.upgrades = { ...state.upgrades, ...saved.upgrades };
    } catch(e) { console.log('Save corrupt'); }
}

function saveGame() {
    localStorage.setItem('winterFactorySave', JSON.stringify({
        money: state.money,
        upgrades: state.upgrades
    }));
}

function resetGame() {
    localStorage.removeItem('winterFactorySave');
    location.reload();
}

let player = { x: 0, y: 0, targetX: 0, targetY: 0, moving: false, stack: [], wobble: 0 };
let entities = [];
let particles = [];
let unlockZones = [];

// --- ASSET DRAWING ---
function drawShadow(x, y, r) {
    ctx.fillStyle = 'rgba(0,50,60,0.15)';
    ctx.beginPath();
    ctx.ellipse(x, y, r, r/2, 0, 0, Math.PI*2);
    ctx.fill();
}

function drawMeatItem(x, y, type, index, isMoving) {
    const isRaw = type === 'raw';
    const c = isRaw ? COLORS.meatRaw : COLORS.meatCooked;
    const yOff = y - (index * 14);
    const sway = Math.sin(state.time * 5 + index) * (isMoving ? 3 : 1);
    const xOff = x + sway;
    
    ctx.fillStyle = c;
    ctx.beginPath();
    ctx.roundRect(xOff - 12, yOff - 40, 24, 12, 4);
    ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(xOff - 12, yOff - 34, 24, 4); // Side depth
    
    if (isRaw) {
        ctx.fillStyle = '#ffcccc'; // Fat
        ctx.beginPath(); ctx.arc(xOff, yOff - 34, 3, 0, Math.PI*2); ctx.fill();
    } else {
        ctx.fillStyle = '#5d4037'; // Grill marks
        ctx.fillRect(xOff - 8, yOff - 38, 2, 8);
        ctx.fillRect(xOff + 8, yOff - 38, 2, 8);
    }
}

function drawPerson(x, y, coatColor, hatColor, isMoving, stack = [], isHungry = false) {
    drawShadow(x, y, 18);
    const bounce = isMoving ? Math.abs(Math.sin(state.time * 12)) * 4 : 0;
    
    // Coat
    ctx.fillStyle = coatColor;
    ctx.beginPath();
    ctx.roundRect(x - 12, y - 35 - bounce, 24, 30, 8);
    ctx.fill();
    
    // Head
    ctx.fillStyle = COLORS.playerSkin;
    ctx.beginPath();
    ctx.arc(x, y - 42 - bounce, 12, 0, Math.PI*2);
    ctx.fill();
    
    // Face
    if (isHungry) {
        ctx.fillStyle = '#c0392b';
        ctx.beginPath(); ctx.ellipse(x, y - 38 - bounce, 4, 3, 0, 0, Math.PI); ctx.fill();
    } 

    // Hat
    ctx.fillStyle = hatColor;
    ctx.beginPath();
    ctx.arc(x, y - 46 - bounce, 13, Math.PI, 0);
    ctx.fill();

    // Stack
    stack.forEach((type, i) => drawMeatItem(x, y - 50 - bounce, type, i, isMoving));
}

function drawBear(b) {
    const breath = 1 + Math.sin(state.time * 2 + b.id) * 0.02;
    const legSwing = Math.sin(state.time * 8 + b.id) * 5;
    drawShadow(b.x, b.y, 35);
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.scale(breath, breath);
    
    // Legs
    ctx.fillStyle = COLORS.bearShadow;
    ctx.beginPath();
    ctx.roundRect(-15 + legSwing, -10, 8, 15, 4);
    ctx.roundRect(5 - legSwing, -10, 8, 15, 4);
    ctx.fill();
    
    // Body
    ctx.fillStyle = COLORS.bear;
    ctx.beginPath(); ctx.roundRect(-25, -30, 45, 28, 14); ctx.fill();
    
    // Head
    ctx.beginPath(); ctx.arc(-22, -25, 14, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(-30, -34, 5, 0, Math.PI*2); ctx.fill(); // Ears
    ctx.beginPath(); ctx.arc(-14, -34, 5, 0, Math.PI*2); ctx.fill();
    
    // Face
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(-28, -25, 2.5, 0, Math.PI*2); ctx.fill(); // Eye
    ctx.beginPath(); ctx.ellipse(-26, -20, 3, 2, 0, 0, Math.PI*2); ctx.fill(); // Nose

    ctx.restore();
}

function drawMachine(m) {
    // Base
    ctx.fillStyle = '#7f8c8d';
    ctx.fillRect(m.x - 35, m.y - 10, 70, 10);
    
    // Belt
    ctx.save();
    ctx.translate(m.x, m.y - 15);
    ctx.rotate(-0.05);
    ctx.fillStyle = COLORS.belt;
    ctx.fillRect(-35, -5, 70, 20);
    if (m.processing) {
        ctx.fillStyle = COLORS.beltMoving;
        const off = (state.time * 50) % 20;
        for(let i=-35+off; i<35; i+=20) if(i<30) ctx.fillRect(i, -5, 5, 20);
    }
    ctx.restore();
    
    // Grill
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(m.x + 5, m.y - 40, 30, 30);
    if (m.processing) {
        ctx.fillStyle = `rgba(230, 126, 34, ${0.5 + Math.sin(state.time*15)*0.3})`;
        ctx.beginPath(); ctx.arc(m.x + 20, m.y - 35, 12, 0, Math.PI*2); ctx.fill();
    }
    
    // Output Stack
    for(let i=0; i<m.output; i++) drawMeatItem(m.x - 20, m.y - 10, 'cooked', i, false);
}

// --- LOGIC HELPER ---
function getDist(o1, o2) { return Math.hypot(o1.x - o2.x, o1.y - o2.y); }

// --- GAME SETUP ---
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (player.x === 0) {
        player.x = canvas.width/2; 
        player.y = canvas.height/2;
        player.targetX = player.x; 
        player.targetY = player.y;
    }
    setupUnlockZones();
}

function setupUnlockZones() {
    unlockZones = [];
    const baseY = 80;
    
    // Speed Upgrade
    if (state.upgrades.speed < 3) {
        const cost = (state.upgrades.speed + 1) * 80;
        unlockZones.push({ x: canvas.width/2, y: baseY, w: 140, h: 80, cost: cost, label: `SPEED UP`, type: 'speed' });
    }
    
    // Hunter Hire
    if (state.upgrades.hunters < 3) {
        const cost = 60 + (state.upgrades.hunters * 100);
        unlockZones.push({ x: canvas.width/2 - 160, y: baseY, w: 140, h: 80, cost: cost, label: `HIRE HUNTER`, type: 'hunter' });
    }
    
    // Waiter Hire
    if (state.upgrades.waiters < 3) {
        const cost = 100 + (state.upgrades.waiters * 150);
        unlockZones.push({ x: canvas.width/2 + 160, y: baseY, w: 140, h: 80, cost: cost, label: `HIRE WAITER`, type: 'waiter' });
    }
}

function initGame() {
    resize();
    window.addEventListener('resize', resize);
    
    // Input
    const setTarget = (e) => { 
        const t = e.touches ? e.touches[0] : e;
        player.targetX = t.clientX;
        player.targetY = t.clientY;
    };
    canvas.addEventListener('mousedown', (e) => { setTarget(e); canvas.addEventListener('mousemove', setTarget); });
    window.addEventListener('mouseup', () => canvas.removeEventListener('mousemove', setTarget));
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); setTarget(e); canvas.addEventListener('touchmove', setTarget); }, {passive:false});
    window.addEventListener('touchend', () => canvas.removeEventListener('touchmove', setTarget));

    // World Init
    entities.push({ type: 'machine', x: canvas.width/2 - 100, y: canvas.height/2 + 100, input: 0, output: 0, maxOutput: 5, timer: 0, processing: false });
    entities.push({ type: 'table', x: canvas.width/2 + 100, y: canvas.height/2 + 100, food: 0, maxFood: 5, w: 60, h: 20 });
    
    // Load Employees
    for(let i=0; i<state.upgrades.hunters; i++) spawnEmployee('hunter');
    for(let i=0; i<state.upgrades.waiters; i++) spawnEmployee('waiter');

    requestAnimationFrame(loop);
}

function spawnEmployee(role) {
    entities.push({
        type: 'employee',
        role: role,
        x: canvas.width/2,
        y: 150,
        stack: [],
        state: 'idle',
        targetEntity: null,
        speed: 180
    });
}

function spawnBear() {
    if (entities.filter(e => e.type === 'bear').length < 6) {
        entities.push({ 
            type: 'bear', id: Math.random(), 
            x: Math.random() * (canvas.width - 50) + 25, 
            y: Math.random() * (canvas.height/2) + canvas.height/2, // Bottom half 
            hp: 1 
        });
    }
}

// --- UPDATE LOOP ---
let lastTime = 0;
function loop(timestamp) {
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    state.time = timestamp / 1000;
    
    update(dt);
    draw();
    requestAnimationFrame(loop);
}

function update(dt) {
    // 1. Player
    const pSpeed = BASE_SPEED + (state.upgrades.speed * 40);
    const dx = player.targetX - player.x, dy = player.targetY - player.y;
    const dist = Math.hypot(dx, dy);
    player.moving = dist > 5;
    if (dist > 5) {
        player.x += (dx/dist) * pSpeed * dt;
        player.y += (dy/dist) * pSpeed * dt;
    }

    // 2. Unlock Zones
    unlockZones.forEach(zone => {
        if (state.money >= zone.cost && 
            player.x > zone.x - zone.w/2 && player.x < zone.x + zone.w/2 &&
            player.y > zone.y - zone.h/2 && player.y < zone.y + zone.h/2) {
            
            // Purchase!
            state.money -= zone.cost;
            particles.push({ type:'text', text:'UNLOCKED!', x: zone.x, y: zone.y, life: 1.5 });
            
            if (zone.type === 'speed') state.upgrades.speed++;
            if (zone.type === 'hunter') { state.upgrades.hunters++; spawnEmployee('hunter'); }
            if (zone.type === 'waiter') { state.upgrades.waiters++; spawnEmployee('waiter'); }
            
            saveGame();
            setupUnlockZones(); // Refresh zones
        }
    });

    // 3. Entities
    entities.forEach(e => {
        // Bear Logic
        if (e.type === 'bear') {
            // Player Interaction
            if (getDist(player, e) < 50 && player.stack.length < MAX_STACK) {
                e.hp = 0; player.stack.push('raw');
                spawnPop(e.x, e.y);
            }
        }

        // Machine Logic
        if (e.type === 'machine') {
            // Player Interaction
            if (getDist(player, e) < 70) {
                if (player.stack.length > 0 && player.stack[player.stack.length-1] === 'raw') {
                    player.stack.pop(); e.input++; e.processing = true;
                }
                if (e.output > 0 && player.stack.length < MAX_STACK) {
                    e.output--; player.stack.push('cooked');
                }
            }
            // Cooking
            if (e.input > 0 && e.output < e.maxOutput) {
                e.timer += dt;
                if (Math.random() > 0.92) spawnSmoke(e.x+20, e.y-40);
                if (e.timer > 1.5) { e.input--; e.output++; e.timer = 0; }
            } else { e.processing = false; }
        }

        // Table Logic
        if (e.type === 'table') {
            if (getDist(player, e) < 70 && player.stack.length > 0 && player.stack[player.stack.length-1] === 'cooked' && e.food < e.maxFood) {
                player.stack.pop(); e.food++;
            }
        }

        // Employee Logic (AI)
        if (e.type === 'employee') {
            if (e.role === 'hunter') {
                if (e.state === 'idle') {
                    // Find Bear
                    const target = entities.find(b => b.type === 'bear' && b.hp > 0);
                    if (target) { e.targetEntity = target; e.state = 'hunting'; }
                    else { e.targetEntity = {x: canvas.width/2 + (Math.random()-0.5)*200, y: 300}; e.state = 'wandering'; }
                } else if (e.state === 'hunting') {
                    if (!e.targetEntity || e.targetEntity.hp <= 0) { e.state = 'idle'; return; }
                    moveTo(e, e.targetEntity.x, e.targetEntity.y, e.speed, dt);
                    if (getDist(e, e.targetEntity) < 40) {
                        e.targetEntity.hp = 0; // Kill
                        spawnPop(e.targetEntity.x, e.targetEntity.y);
                        // Hunter doesn't carry, just kills (player picks up for now, or drops meat?)
                        // Let's make hunter drop meat on ground? 
                        // Simplified: Hunter kills, meat flies to player? No, that's magic.
                        // Let's make Hunter carry 1 meat to machine.
                        e.stack.push('raw');
                        e.state = 'delivering';
                    }
                } else if (e.state === 'delivering') {
                    const machine = entities.find(m => m.type === 'machine');
                    moveTo(e, machine.x - 40, machine.y, e.speed, dt);
                    if (getDist(e, {x: machine.x-40, y: machine.y}) < 10) {
                        e.stack.pop(); machine.input++; machine.processing = true;
                        e.state = 'idle';
                    }
                } else if (e.state === 'wandering') {
                    moveTo(e, e.targetEntity.x, e.targetEntity.y, e.speed*0.5, dt);
                    if (getDist(e, e.targetEntity) < 10) e.state = 'idle';
                }
            }
            if (e.role === 'waiter') {
                const machine = entities.find(m => m.type === 'machine');
                const table = entities.find(t => t.type === 'table');
                
                if (e.stack.length === 0) {
                    // Go to machine
                    if (machine.output > 0) {
                        moveTo(e, machine.x, machine.y, e.speed, dt);
                        if (getDist(e, machine) < 60) {
                            machine.output--; e.stack.push('cooked');
                        }
                    } else {
                        // Idle near machine
                         moveTo(e, machine.x + 50, machine.y + 50, e.speed * 0.5, dt);
                    }
                } else {
                    // Go to table
                    if (table.food < table.maxFood) {
                        moveTo(e, table.x, table.y, e.speed, dt);
                        if (getDist(e, table) < 60) {
                            e.stack.pop(); table.food++;
                        }
                    }
                }
            }
        }

        // Customer Logic
        if (e.type === 'customer') {
            const table = entities.find(t => t.type === 'table');
            if (e.state === 'walking') {
                moveTo(e, table.x, table.y + 40, 100, dt);
                if (getDist(e, {x: table.x, y: table.y+40}) < 10) {
                    if (table.food > 0) {
                        table.food--; e.state = 'eating'; e.timer = 2;
                    }
                }
            } else if (e.state === 'eating') {
                e.timer -= dt;
                if (e.timer <= 0) {
                    state.money += 15;
                    particles.push({type:'text', text:'+$15', x: e.x, y: e.y - 60, life:1});
                    saveGame();
                    e.state = 'leaving';
                }
            } else if (e.state === 'leaving') {
                e.y += 100 * dt;
                if (e.y > canvas.height + 50) e.dead = true;
            }
        }
    });

    // Spawners & Cleanup
    if (Math.random() < 0.02) spawnBear();
    if (entities.filter(e => e.type === 'customer').length < 3 && Math.random() < 0.01) {
        entities.push({ type: 'customer', x: Math.random() * canvas.width, y: canvas.height + 50, state: 'walking', timer: 0 });
    }
    
    entities = entities.filter(e => !e.dead && (e.type !== 'bear' || e.hp > 0));
    
    particles.forEach(p => { p.y -= 20 * dt; p.life -= dt; });
    particles = particles.filter(p => p.life > 0);
    
    // UI Update
    uiMoney.innerText = state.money;
    uiMeat.innerText = `${player.stack.length}/${MAX_STACK}`;
}

function moveTo(entity, tx, ty, spd, dt) {
    const dx = tx - entity.x, dy = ty - entity.y;
    const d = Math.hypot(dx, dy);
    if (d > 5) {
        entity.x += (dx/d) * spd * dt;
        entity.y += (dy/d) * spd * dt;
    }
}

function spawnPop(x, y) {
    for(let i=0; i<5; i++) particles.push({ type: 'snow', x: x, y: y, size: 4, life: 0.5 });
}
function spawnSmoke(x, y) {
    particles.push({ type:'smoke', x: x, y: y, size: 5, life: 1 });
}

// --- DRAW ---
function draw() {
    ctx.fillStyle = COLORS.snow; ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw Unlock Zones
    unlockZones.forEach(z => {
        const canAfford = state.money >= z.cost;
        const color = canAfford ? COLORS.unlockActive : COLORS.unlockLocked;
        
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.roundRect(z.x - z.w/2, z.y - z.h/2, z.w, z.h, 10); ctx.fill();
        ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.stroke();
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center';
        ctx.fillText(z.label, z.x, z.y - 5);
        ctx.fillText(`$${z.cost}`, z.x, z.y + 15);
    });

    // Z-Sort & Draw Entities
    const renderList = [
        { y: player.y, draw: () => drawPerson(player.x, player.y, COLORS.playerCoat, '#2c3e50', player.moving, player.stack) },
        ...entities.map(e => ({
            y: e.y,
            draw: () => {
                if(e.type === 'bear') drawBear(e);
                if(e.type === 'machine') drawMachine(e);
                if(e.type === 'table') {
                    // Draw table block
                    ctx.fillStyle = '#a1887f'; ctx.fillRect(e.x - 30, e.y - 10, 60, 20);
                    ctx.fillStyle = 'white'; ctx.fillRect(e.x - 30, e.y - 10, 60, 5); // Cloth
                    for(let i=0; i<e.food; i++) drawMeatItem(e.x - 20 + (i*10), e.y, 'cooked', 0, false);
                }
                if(e.type === 'customer') drawPerson(e.x, e.y, COLORS.customerCoat, COLORS.customerHat, e.state!=='eating', [], e.state!=='leaving');
                if(e.type === 'employee') {
                    const coat = e.role === 'hunter' ? COLORS.hunterCoat : COLORS.waiterCoat;
                    drawPerson(e.x, e.y, coat, '#333', true, e.stack, false);
                }
            }
        }))
    ];
    renderList.sort((a, b) => a.y - b.y);
    renderList.forEach(o => o.draw());

    // Particles
    particles.forEach(p => {
        if(p.type==='text') { ctx.fillStyle = '#2ecc71'; ctx.font = 'bold 20px Arial'; ctx.fillText(p.text, p.x, p.y); }
        else if(p.type==='smoke') { ctx.fillStyle='rgba(100,100,100,0.5)'; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); }
        else { ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); }
    });
}

initGame();
</script>
</body>
</html>