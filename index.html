<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Boredom Brawler</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#0b0f1a; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #wrap { height: 100%; display:flex; align-items:center; justify-content:center; }
    canvas { width:min(96vw, 520px); height:min(86vh, 920px); background: radial-gradient(120% 120% at 50% 20%, #141b33 0%, #070a12 65%, #05060b 100%); border-radius:18px; box-shadow: 0 18px 60px rgba(0,0,0,.55); touch-action:none; }
    .hint { position:fixed; left:0; right:0; bottom:10px; text-align:center; color:#9fb2ff; font-size:12px; opacity:.9; user-select:none; pointer-events:none; }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="c" width="520" height="920"></canvas></div>
  <div class="hint">Tap/drag to move • Auto-fire • Survive the boredom waves • Space/Enter to start</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // --- Utility
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const now = () => performance.now();

  // --- Audio (simple beeps)
  let audioOK = false;
  let ac = null;
  function initAudio() {
    if (audioOK) return;
    try {
      ac = new (window.AudioContext || window.webkitAudioContext)();
      audioOK = true;
    } catch {}
  }
  function beep(freq=440, dur=0.06, type="sine", gain=0.05) {
    if (!audioOK || !ac) return;
    const t = ac.currentTime;
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.setValueAtTime(gain, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.connect(g); g.connect(ac.destination);
    o.start(t); o.stop(t + dur);
  }

  // --- Game state
  const W = canvas.width, H = canvas.height;
  const world = { w: W, h: H, t: 0, dt: 16.67, last: now() };

  const storeKey = "boredom_brawler_high";
  let high = +localStorage.getItem(storeKey) || 0;

  const player = {
    x: W/2, y: H*0.82,
    r: 18,
    hp: 3,
    speed: 11,
    invuln: 0,
    score: 0,
    combo: 0,
    comboT: 0,
    fireCd: 0
  };

  const bullets = [];
  const enemies = [];
  const particles = [];

  let game = {
    mode: "menu", // menu | play | over
    wave: 1,
    spawnCd: 0,
    difficulty: 1,
    shake: 0,
    msg: "Boredom Brawler"
  };

  // --- Input (touch + mouse + keyboard)
  let pointerDown = false;
  let targetX = player.x, targetY = player.y;
  function pointerPos(e) {
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left) * (canvas.width / r.width);
    const y = (e.clientY - r.top) * (canvas.height / r.height);
    return { x, y };
  }
  function setTarget(x, y) {
    targetX = clamp(x, 30, W-30);
    targetY = clamp(y, 90, H-30);
  }

  canvas.addEventListener("pointerdown", (e) => {
    initAudio();
    pointerDown = true;
    canvas.setPointerCapture(e.pointerId);
    const p = pointerPos(e);
    setTarget(p.x, p.y);
    if (game.mode !== "play") start();
  });
  canvas.addEventListener("pointermove", (e) => {
    if (!pointerDown) return;
    const p = pointerPos(e);
    setTarget(p.x, p.y);
  });
  canvas.addEventListener("pointerup", () => pointerDown = false);
  window.addEventListener("keydown", (e) => {
    if (e.key === " " || e.key === "Enter") { initAudio(); if (game.mode !== "play") start(); }
    const step = 26;
    if (game.mode === "play") {
      if (e.key === "ArrowLeft" || e.key === "a") setTarget(targetX - step, targetY);
      if (e.key === "ArrowRight" || e.key === "d") setTarget(targetX + step, targetY);
      if (e.key === "ArrowUp" || e.key === "w") setTarget(targetX, targetY - step);
      if (e.key === "ArrowDown" || e.key === "s") setTarget(targetX, targetY + step);
    }
  });

  // --- Entities
  function spawnEnemy() {
    const side = Math.random() < 0.5 ? "top" : "side";
    let x, y, vx, vy;
    if (side === "top") {
      x = rand(40, W-40); y = -30;
      vx = rand(-0.6, 0.6) * game.difficulty;
      vy = rand(1.4, 2.2) * game.difficulty;
    } else {
      const left = Math.random() < 0.5;
      x = left ? -30 : W + 30;
      y = rand(80, H*0.55);
      vx = (left ? rand(1.3, 2.2) : -rand(1.3, 2.2)) * game.difficulty;
      vy = rand(0.8, 1.6) * game.difficulty;
    }
    const r = rand(16, 28);
    const hp = r > 24 ? 3 : (r > 20 ? 2 : 1);
    enemies.push({
      x, y, vx, vy, r, hp,
      wob: rand(0, Math.PI*2),
      kind: Math.random() < 0.2 ? "chunky" : "floaty"
    });
  }

  function fire() {
    bullets.push({ x: player.x, y: player.y-18, vx: 0, vy: -15, r: 5 });
    beep(740, 0.04, "square", 0.03);
  }

  function burst(x,y, n=14) {
    for (let i=0;i<n;i++){
      const a = rand(0, Math.PI*2);
      const sp = rand(2, 8);
      particles.push({ x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life: rand(260, 520) });
    }
  }

  function damagePlayer() {
    if (player.invuln > 0) return;
    player.hp -= 1;
    player.invuln = 900;
    game.shake = 14;
    player.combo = 0;
    player.comboT = 0;
    beep(120, 0.09, "sawtooth", 0.05);
    if (player.hp <= 0) end();
  }

  // --- Flow
  function reset() {
    bullets.length = 0; enemies.length = 0; particles.length = 0;
    player.x = W/2; player.y = H*0.82;
    targetX = player.x; targetY = player.y;
    player.hp = 3;
    player.score = 0;
    player.combo = 0;
    player.comboT = 0;
    player.fireCd = 0;
    player.invuln = 0;
    game.wave = 1;
    game.spawnCd = 700;
    game.difficulty = 1;
    game.shake = 0;
    game.msg = "Boredom Brawler";
  }

  function start() {
    reset();
    game.mode = "play";
    beep(520, 0.06, "triangle", 0.04);
    beep(660, 0.06, "triangle", 0.04);
  }

  function end() {
    game.mode = "over";
    high = Math.max(high, Math.floor(player.score));
    localStorage.setItem(storeKey, String(high));
    burst(player.x, player.y, 28);
    beep(220, 0.10, "sine", 0.05);
    setTimeout(() => beep(180, 0.12, "sine", 0.05), 90);
  }

  // --- Update
  function step() {
    const t = now();
    world.dt = clamp(t - world.last, 0, 34);
    world.last = t;
    world.t += world.dt;

    update(world.dt);
    draw();

    requestAnimationFrame(step);
  }

  function update(dt) {
    if (game.shake > 0) game.shake = Math.max(0, game.shake - dt*0.04);

    // Background particles
    if (Math.random() < 0.08 && particles.length < 180) {
      particles.push({ x: rand(0,W), y: rand(0,H), vx: rand(-0.2,0.2), vy: rand(0.6,1.3), life: rand(900, 1800), bg:true });
    }

    // Menu/Over idle motion
    if (game.mode !== "play") {
      player.x += Math.sin(world.t*0.002) * 0.25;
      player.y += Math.cos(world.t*0.0017) * 0.18;
    }

    // Particles
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.life -= dt;
      p.x += p.vx * (dt/16.67);
      p.y += p.vy * (dt/16.67);
      if (p.bg && p.y > H+30) { p.y = -20; p.x = rand(0,W); }
      if (!p.bg) { p.vx *= 0.985; p.vy *= 0.985; }
      if (p.life <= 0) particles.splice(i,1);
    }

    if (game.mode !== "play") return;

    // Player movement toward target
    const lerp = 1 - Math.pow(0.001, dt/16.67);
    player.x += (targetX - player.x) * lerp;
    player.y += (targetY - player.y) * lerp;

    // Invulnerability
    if (player.invuln > 0) player.invuln = Math.max(0, player.invuln - dt);

    // Combo timer
    if (player.comboT > 0) player.comboT = Math.max(0, player.comboT - dt);
    if (player.comboT === 0) player.combo = 0;

    // Auto-fire
    player.fireCd = Math.max(0, player.fireCd - dt);
    if (player.fireCd === 0) {
      fire();
      player.fireCd = 180; // ms
    }

    // Spawn scaling
    game.spawnCd -= dt;
    if (game.spawnCd <= 0) {
      spawnEnemy();
      const base = clamp(680 - game.wave*22, 220, 680);
      game.spawnCd = base / game.difficulty;
    }

    // Ramp difficulty by score
    game.difficulty = 1 + player.score / 900;
    game.wave = 1 + Math.floor(player.score / 180);

    // Bullets
    for (let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.x += b.vx * (dt/16.67);
      b.y += b.vy * (dt/16.67);
      if (b.y < -30) bullets.splice(i,1);
    }

    // Enemies
    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      e.wob += dt*0.004;
      const wobble = Math.sin(e.wob) * (e.kind==="chunky" ? 0.7 : 1.4);
      e.x += (e.vx + wobble) * (dt/16.67);
      e.y += e.vy * (dt/16.67);

      // Collide with player
      const dxp = e.x - player.x, dyp = e.y - player.y;
      const rr = e.r + player.r;
      if (dxp*dxp + dyp*dyp < rr*rr) {
        damagePlayer();
        burst(e.x, e.y, 16);
        enemies.splice(i,1);
        continue;
      }

      // Offscreen bottom
      if (e.y > H + 60) {
        enemies.splice(i,1);
        // Penalty for letting boredom slip through
        player.score = Math.max(0, player.score - 15);
        player.combo = 0;
        player.comboT = 0;
      }
    }

    // Bullet vs enemy
    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      for (let j=bullets.length-1;j>=0;j--){
        const b = bullets[j];
        const dx = e.x - b.x, dy = e.y - b.y;
        const rr = e.r + b.r;
        if (dx*dx + dy*dy < rr*rr) {
          bullets.splice(j,1);
          e.hp -= 1;
          burst(b.x, b.y, 6);
          beep(560, 0.03, "triangle", 0.02);

          if (e.hp <= 0) {
            enemies.splice(i,1);
            const mult = 1 + Math.min(6, player.combo) * 0.2;
            player.score += Math.floor(20 * mult);
            player.combo += 1;
            player.comboT = 1100;
            game.shake = Math.min(18, game.shake + 2.5);
            burst(e.x, e.y, 22);
            beep(820, 0.05, "square", 0.03);
          } else {
            player.score += 2;
          }
          break;
        }
      }
    }
  }

  // --- Draw
  function draw() {
    // Screen shake
    let sx = 0, sy = 0;
    if (game.shake > 0) {
      sx = rand(-game.shake, game.shake);
      sy = rand(-game.shake, game.shake);
    }

    ctx.save();
    ctx.clearRect(0,0,W,H);
    ctx.translate(sx, sy);

    // Background glow rings
    ctx.globalAlpha = 0.9;
    for (let i=0;i<3;i++){
      ctx.beginPath();
      ctx.arc(W*0.5, H*0.25, 150 + i*120 + Math.sin(world.t*0.001+i)*18, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(120,150,255,${0.07 - i*0.015})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // Particles
    for (const p of particles) {
      const a = p.bg ? 0.35 : 0.9;
      ctx.globalAlpha = a * Math.min(1, p.life/300);
      ctx.fillStyle = p.bg ? "rgba(160,190,255,0.55)" : "rgba(210,225,255,0.9)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.bg ? 1.2 : 2.2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Enemies (boredom blobs)
    for (const e of enemies) {
      const g = ctx.createRadialGradient(e.x-e.r*0.3, e.y-e.r*0.3, 2, e.x, e.y, e.r*1.2);
      g.addColorStop(0, "rgba(180,140,255,0.95)");
      g.addColorStop(1, "rgba(75,40,135,0.95)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
      ctx.fill();

      // face
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = "rgba(10,12,20,0.9)";
      ctx.beginPath(); ctx.arc(e.x - e.r*0.25, e.y - 2, 3.2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(e.x + e.r*0.18, e.y - 2, 3.2, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;

      // HP ring
      ctx.globalAlpha = 0.75;
      ctx.strokeStyle = "rgba(220,230,255,0.7)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r+6, -Math.PI/2, -Math.PI/2 + (Math.PI*2)*(e.hp/3));
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Bullets (focus sparks)
    for (const b of bullets) {
      ctx.fillStyle = "rgba(180,255,220,0.95)";
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      ctx.arc(b.x, b.y+8, b.r+6, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Player (shielded cursor)
    const blink = (player.invuln > 0) && (Math.floor(world.t/90) % 2 === 0);
    if (!blink) {
      const pg = ctx.createRadialGradient(player.x-10, player.y-10, 3, player.x, player.y, 26);
      pg.addColorStop(0, "rgba(120,255,220,1)");
      pg.addColorStop(1, "rgba(40,120,95,1)");
      ctx.fillStyle = pg;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
      ctx.fill();

      // ring
      ctx.strokeStyle = "rgba(220,255,245,0.7)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r+8, 0, Math.PI*2);
      ctx.stroke();
    }

    // UI
    ctx.fillStyle = "rgba(235,240,255,0.92)";
    ctx.font = "700 22px system-ui";
    ctx.textAlign = "left";
    ctx.fillText(`Score: ${Math.floor(player.score)}`, 18, 38);

    ctx.font = "600 16px system-ui";
    ctx.fillStyle = "rgba(180,200,255,0.9)";
    ctx.fillText(`High: ${high}`, 18, 62);
    ctx.fillText(`Wave: ${game.wave}`, 18, 86);

    // Hearts
    for (let i=0;i<3;i++){
      const x = W - 24 - i*26, y = 30;
      ctx.globalAlpha = i < player.hp ? 1 : 0.22;
      ctx.fillStyle = "rgba(255,120,170,0.92)";
      heart(x,y,10);
    }
    ctx.globalAlpha = 1;

    // Combo
    if (player.combo > 0 && game.mode === "play") {
      ctx.textAlign = "center";
      ctx.fillStyle = "rgba(200,255,240,0.95)";
      ctx.font = "800 20px system-ui";
      ctx.fillText(`Combo x${player.combo}`, W/2, 56);
    }

    // Overlay screens
    if (game.mode === "menu") overlay("Boredom Brawler", "Tap to start. Drag to move. Auto-fire does the rest.");
    if (game.mode === "over") overlay("Game Over", `Score: ${Math.floor(player.score)}   •   High: ${high}\nTap or press Enter to restart.`);

    ctx.restore();
  }

  function overlay(title, subtitle) {
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(5,7,12,0.6)";
    ctx.fillRect(0,0,W,H);

    ctx.textAlign = "center";
    ctx.fillStyle = "rgba(235,245,255,0.96)";
    ctx.font = "900 44px system-ui";
    ctx.fillText(title, W/2, H*0.40);

    ctx.fillStyle = "rgba(170,190,255,0.95)";
    ctx.font = "600 18px system-ui";
    wrapText(subtitle, W/2, H*0.46, W*0.78, 24);

    // Start button
    const bw = 260, bh = 54, bx = W/2 - bw/2, by = H*0.56;
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(120,150,255,0.22)";
    roundRect(bx,by,bw,bh,16,true,false);
    ctx.strokeStyle = "rgba(200,220,255,0.35)";
    ctx.lineWidth = 2;
    roundRect(bx,by,bw,bh,16,false,true);

    ctx.fillStyle = "rgba(235,245,255,0.96)";
    ctx.font = "800 18px system-ui";
    ctx.fillText("START", W/2, by+35);

    ctx.restore();
  }

  function wrapText(text, x, y, maxW, lineH) {
    const lines = String(text).split("\n");
    let yy = y;
    for (const part of lines) {
      const words = part.split(" ");
      let line = "";
      for (const w of words) {
        const test = line ? line + " " + w : w;
        if (ctx.measureText(test).width > maxW) {
          ctx.fillText(line, x, yy);
          yy += lineH;
          line = w;
        } else line = test;
      }
      if (line) { ctx.fillText(line, x, yy); yy += lineH; }
      yy += 6;
    }
  }

  function roundRect(x,y,w,h,r,fill,stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function heart(x, y, s) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x, y - s*0.7, x - s, y - s*0.7, x - s, y);
    ctx.bezierCurveTo(x - s, y + s*0.7, x, y + s*1.1, x, y + s*1.6);
    ctx.bezierCurveTo(x, y + s*1.1, x + s, y + s*0.7, x + s, y);
    ctx.bezierCurveTo(x + s, y - s*0.7, x, y - s*0.7, x, y);
    ctx.fill();
  }

  // Start loop
  reset();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>